#### Chapter 4. 쿼리
find 소개
쿼리에 사용.

컬렉션에서 도큐먼트의 서브셋을 반환.

첫번째 매개변수에 따라 어떤 도큐먼트를 가져올지 결정됨.

db.c.find() → 매개 변수에 도큐먼트가 없으면 모두 조회.

여러 키/값 쌍을 추가해 검색을 제한할 수 있음.


// 이름, 나이 .... and 조건으로 조회
db.users.find({"username" "joe", "age" 27});
원하는 반환 정보 지정


// 이름, 이메일 만 지정.
// select m.username, m.email from user; 랑 비슷
db.users.find({}, {"username": 1, "email": 1});

// 제외도 가능
db.users.find({}, {"username": 1, "_id": 0});
제약 사항

쿼리 도큐먼트 값은 반드시 상수여야 함. → 도큐먼트 내 다른 키의 값을 참조할 수 없음을 의미. (이해가 잘 안됨)

쿼리 조건
완전 일치, 범위, or, 부정 등 더 복잡한 조건으로 검색 가능.

쿼리 조건절

<, ≤, >, ≥ 에 해당하는 “$lt”, “$lte”, “$gt”, “$gte” 다.

조합 하여 특정 범위 쿼리 가능.


// 나이가 18 이상 30 이하 도큐먼트 조회
db.users.find({"age" {"$gte" 18, "$lte" 30}});
불일치(not equal) 는 “$ne” 사용.

OR 쿼리

두 가지 방법 존재.

“$in” 을 통한 하나의 값을 다양한 값과 비교하는 쿼리에 사용.

유연해서 여러값, 여러 데이터형도 사용 가능.


db.users.find({“user id" {“$in" [12345, "joe"}});

// 반대로 조건과 불일치 하는 도큐먼트 반환 -> "$nin"
db.rattle.find({"tlcket no" {"$nin" [725, 542, 390]}});
“$or” 는 더 일반적이고 여러 키를 주어진 값과 비교하는 쿼리에 사용.


// 티켓 번호가 세 번호 중 적어도 하나와 일치하거나 위너가 참인 경우 찾기
db.raffle.find({"$or": [{"ticket_no" {"$in": [725, 542, 390]}}, {"winner" true}]});
“$or” 연산자가 항상 작동하는 동안에는 가능한 "$in"을 사용하자. 쿼리 옵티마이저는 “$in”을 더 효율적으로 다룬다.

$not

메타 조건절로 어떤 조건에도 적용 가능.

정규 표현식과 함께 사용해 주어진 패턴과 일치하지 않는 도큐먼트를 찾을 때 특히 유용함.

형 특정 쿼리
null

스스로와 일치하는 것을 찾음.


db.c.find({"z": null});

// 결과: z와 일치하지 않거나, z가 존재하지 않은 모든 값을 조회함
{"_id": ObjectId("4ba0f148d22aa494fd52362336"), "y" : null }
{"_id": ObjectId("4ba0f148d22aa494fd52361235"), "y" : 1 }
{"_id": ObjectId("4ba0f148d22aa494fd51231231"), "y" : 2 }

// 값이 null 인 것만 찾고 싶으면 null 인 값을 쿼리하고, "$exists" 조건절을 사용해 null 존재 여부를 확인 하면 됨.
db.c.find({"z" {"$eq" null, "$exists" true}});
정규 표현식

“$regex” 로 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공.

몽고디비는 정규 표현식 일치에 펄 호환 정규 표현식 PCRE 라이브러리를 사용하여, PCRE 에서 사용가능한 모든 문법을 몽고에서 사용 가능함.

배열에 쿼리하기


food: {
"fruit": ["apple", "banana", "peach"]
}

db.food.find({"fruit": "banana"});
$all 연산자

2개 이상의 배열 요소가 일치하는 배열을 찾을 때 사용.

순서는 중요하지 않음.

완벽하게 요소가 일치하는 도큐먼트 찾기 가능.


db.food.find({"fruit": {"$all": ["apple", "banana"]}});

// 완벽하게 요소가 일치하는 도큐먼트
db.food.find({"fruit": {"$all": ["apple", "banana", "peach"]}});
$size 연산자

특정 크기의 배열을 쿼리함.


db.food.find({"fruit" {"$size" 3}});
$slice 연산자

find의 (선택적인) 두 번째 매개변수에는 반환받을 특정 키를 지정함.

해당 연산자를 통해 배열 요소의 부분집합을 반환받을 수 있음.


// 게시물에 먼저 달린 댓글 10개 반환
db.blog.posts.findOne(criteria, {"comments" {"$slice" 10}});
// 게시물에 나중에 달린 댓글 10개 반환
db.blog.posts.findOne(criteria, {"comments" {"$slice" -10}});
// 게시물에 원하는 범위 안에 있는 결과 반환 (23개 건너뛰고 24번째 부터 33번까지 반환)
db.blog.posts.findOne(criteria, {"comments" {"$sliιe" [23, 10]}});
일치하는 배열 요소의 반환

배열 요소의 인덱스를 알고 있다면 $slice 연산자가 유용하지만, 때로는 특정 기준과 일치하는 배열 요소를 원할 수도 있음.

$ 연산자 사용하면 일치하는 요소 반환 가능.


// bob이 쓴 글중 첫 번째로 일치하는 댓글만 반환.
db.blog.posts.find({"comments.name": "bob"}, {"comments.$": 1});
********************배열 및 범위 쿼리의 상호작용 (내용이 좀 복잡해 자세한 건 책 내용 참고)

$elemMatch 연산자를 사용하여 비교.

하지만, 비배열 요소를 일치시키지 않는 함정이 있음.

내장 도큐먼트에 쿼리하기 (위 배열 범위 쿼리의 상호작용과 함께 보기)

도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉨.

전체 도큐먼트 대상 쿼리는 일반적인 쿼리와 동일하게 작동.

하지만, 서브 도큐먼트 전체에 쿼리하면 정확하게 일치해야함.

내장 도큐먼트 쿼리는 가능하다면 특정 키로 쿼리하는 방법이 좋음.

도큐먼트 전체를 대상으로 정확히 일치시키는 방법이 아니므로 스키마가 변경되더라도 모든 쿼리가 정상적으로 작동함.

$where 쿼리
키/값 쌍으로 다양한 쿼리를 할 수 있지만 정확하게 표현할 수 없는 쿼리도 존재함.

이때 $where 절을 사용해 임의의 자바스크립트를 쿼리 일부분으로 실행하면 모든 쿼리 표현이 가능함.

보안상의 이유로 $where 사용을 제한해야함.

최종 사용자가 임의의 $where 절을 실행하지 못하도록 한다.

$where 절은 도큐먼트 내 두 키의 값을 비교하는 쿼리에 가장 자주 쓰임.

일반 쿼리 보다 훨씬 느리니 반드시 필요한 경우가 아니면 사용하지 말자.

또 실행 시 각 도큐먼트 BSON에서 자바스크립트 객체로 변환되기 때문에 오래 걸림.

인덱스 사용도 불가.

$where절을 다른 쿼리 필터와 함께 사용하면 성능 저하를 줄일 수 있음.

가능한 한 $where 절이 아닌 조건은 인덱스로 거르고 $where 절은 결과를 세부적으로 조정할 때 사용하자.

$expr 를 사용하면 자바스크립트 실행을 하지 않아 더 빠르게 쿼리할 수 있으므로 $where 대신 $expr를 사용하자.

커서
데이터 베이스는 커서를 사용해 find 의 결과를 반환함.

결과 개수 제한, 결좌 중 몇개 건너뛰기, 여러 키 조합한 결과를 정렬하는 등 다양한 조작 가능.

셸에서 커서 생성하려면 컬렉션에 도큐먼트를 집어넣고 쿼리한 후 결과를 지역 변수로 할당한다.


var cursor = db.collection.find();
이 방법은 컬렉션 내에 무엇이 있는지 보는데 사용하며, 셸에서 실제 프로그래밍을 하는 데는 적합하지 않다.

결과를 얻으려면 커서의 next 메소드를 사용하고 다른 결과가 있는지 확인하려면 hasNext 를 사용함.

cursor는 자바스크립트 반복자 인터페이스를 구현했으므로 forEach 반복문 사용이 가능함.


var cursor = db.people.find();
// find를 호출할 때 셸이 데이터 베이스를 즉시 쿼리하지 않음.
// 결과를 요청하는 쿼리를 보낼때 까지 기다림.
// 따라서, 쿼리 전 옵션 추가 가능.
// 또한 cursor 객체상의 거의 모든 메소드가 커서 자체를 반환하므로 옵션을 어떤 순서로든 이어서 쓸 수 있음.



이 시점에서는 쿼리 수행 안됨.

cursor.hasNext() ⇒ 이때 비로소 쿼리가 실행됨.

제한, 건너뛰기, 정렬

limit()

조건에 맞는 개수 만큼 반환.

skip()

skip(3) → 조건에 맞는 결과중 처음 3개를 건너뛴 나머지를 반환. 3개보다 적으면 결과 반환 안함.

sort()

ex) .sort({username: 1});

1: 오름 차순

-1: 내림차순

비교 순서

몽고 디비는 데이터 형을 비교하는 위계 구조가 있음.

하나의 키에 여러 데이터형 값이 저장되고 섞여 있는 키는 미리 정의된 순서에 따라 정렬함.

정렬 순서를 최솟값에서 최댓값 순으로 나타내면 다음과 같음.




많은 수의 건너뛰기 피하기

많은 수의 도큐멘트가 존재하면 skip 사용 시 느려짐.

대부분 데이터베이스는 skip을 위해 인덱스 안에 메타데이터를 저장하지만 몽고는 아직 해당 기능을 지원하지 않음.

skip 을 사용하지 않고 다른 방법으로 해결


랜덤으로 도큐먼트 찾기(자세한 내용 책 참고)

성능 저하 문제가 많음.

랜덤 키를 별도로 추가하는 방법을 사용하여 skip 대신 랜덤 수를 계산해 쿼리 조건으로 사용하자.

종료되지 않는 커서

커서는 두 가지 측면이 있음.

클라이언트가 보는 커서.

클라이언트 커서가 나타내는 데이터베이스 커서.

서버 측 커서는 메모리와 리소소를 점유함.

커서가 더는 가져올 결과가 없거나 클라이언트로 부터 종료 요청을 받으면 데이터베이스는 점유하고 있던 리소스를 해제함.

그러면 데이터베이스가 리소스를 다른 작업에 사용할 수 있으므로 커서도 신속하게 해제 해야함.

서버 커서를 종료하는 조건

커서는 조건에 일치하는 결과를 모두 살펴본 후에 스스로 정리함.

커서가 클라이언트 측에서 유효 영역을 벗어나면 드라이버는 데이터베이스에 메시지를 보내 커서를 종요해도 된다고 알림.

사용자가 아직 결과를 다 살펴보지 않았고, 커서가 여전히 유요한 영역 내에 있더라도 10분 동안 활동이 없으면 데이터베이스 커서는 자동으로 죽음.

따라서, 몽고 디비 에서 열린 커서가 수천 개가 될 일은 없음.

immortal 이라는 함수로 커서를 타임아웃 하지 못하게 할 수 있음. 반드시 결과를 모두 살펴본 후 명확이 종료해야함!!! 그렇지 않으면 데이터베이스에 남아 서버가 재시작할 때 까지 리소스를 차지함.