### Chapter 9. 애플리케이션 설계
- 스키마 설계 고려 사항
- 데이터 내장 방식과 참조 방식 중 결정하기
- 최적화를 위한 팁
- 일관성 고려 사항
- 스키마 마이그레이션 방법
- 스키마 관리 방법
- 몽고DB가 데이터 스토리지로 적합하지 않은 경우 

#### 9.1 스키마 설계 고려 사항
- 스키마 설계 고려 요소
  - 제약 사항
  - 쿼리 및 쓰기의 접근 패턴
  - 관계 유형 
  - 카디널리티
###### 9.1.1 스키마 설계 패턴
- 다형성 패턴
  - 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 
- 속성 패턴 
  - 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우
  - 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우 
- 버킷 패턴
  - 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합
- 이상치 패턴
  - 드물게 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때
- 계산된 패턴
  - 데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 읽기 집약적일 때 
- 서브셋 패턴 
  - 장비의 램 용량을 초과하는 작업 셋이 있을 때 
- 확장된 참조 패턴
  - 각각 고유한 컬렉션이 있는 여러 논리 엔티티가 있고, 특정 기능을 위해 엔티티들을 모을 때 
- 근사 패턴
  - 리소스가 많이 드는 계산이 필요하지만 높은 정확도가 반드시 필요하지 않은 상황 
- 트리 패턴 
  - 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 
- 사전 할당 패턴
  - 빈 구조를 사전 할당함
- 도큐먼트 버전 관리 패턴
  - 도큐먼트의 이전 법전을 유지함 

#### 9.2 정규화 vs. 비정규화
- 정규화: 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업 
- 비정규화: 모든 데이터를 하나의 도큐먼트에 내장함 
###### 9.2.1 데이터 표현 예제

###### 9.2.2 카디널리티
- 카디널리티: 컬렉션이 다른 컬렉션을 얼마나 참조하는지 

###### 9.2.3 친구, 팔로워 그리고 불편한 관계

#### 9.3 데이터 조작을 위한 최적화
- 읽기 최적화: 올바른 인덱스를 사용해 하나의 도큐먼트에서 가능한 한 많은 정보를 반환함
- 쓰기 최적화: 갖고 있는 인덱스 갯수를 최소화하고 갱신을 가능한 한 효율적으로 수행 

###### 9.3.1 오래된 데이터 제거 
1. TTL 컬렉션
2. 제한 컬렉션 -> 가장 쉬움 
3. 주기마다 컬렉션 삭제 

#### 9.4 데이터베이스와 컬렉션 구상 
- 스키마가 유사한 도큐먼트는 같은 컬렉션 보관 

#### 9.5 일관성 관리
- 서버는 각 연결에 대한 요청 큐 보관 

#### 9.6 스키마 마이그레이션
- 각 도큐먼트에 version 필드 추가

#### 9.7 스키마 관리
- 스키마 유효성 검사를 도입해 갱신 및 삽입 중에 유효성 검사를 허용함 
  - 기존 도큐먼트가 수정되기 전에는 확인하지 않음 

#### 9.8 몽고DB를 사용하지 않는 경우
- 다양한 유형의 데이터를 여러 차원에 걸쳐 조인하는 작업
- SQL알케미, 워드프레스같은 몽고DB를 사용하지 않는 도구일 때 