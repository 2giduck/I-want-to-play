# Ch10. 이벤트

## 10.1 시스템 간 강결합 문제

---

- 쇼핑몰에서 구매를 취소하면 환불 처리
    - 도메인 객체에서 환불 기능을 실행하려면 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행
    
    ```java
    public class Order {
    	public void cancel(RefundService refundService) {
    		// 중략
    		refundService.refund(getPaymentId());
    	}
    }
    ```
    
    - 혹은 응용 서비스에서 실행
    
    ```java
    public class CancelOrderService {
    	private RefundService refundService;
    	
    	public void cancel(OrderNo orderNo) {
    		// 중략
    		refundService.refund(order.getPaymentId());
    	}
    }
    ```
    
- 두 가지 문제
    1. 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매함
        1. 환불 기능을 실행하는 과정에서 익셉션이 발생하면 트랜잭션 롤백? 아니면 그냥 커밋?
    2. 성능 
        1. 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어짐 
- 설계상 문제도 있음 → 주문 로직과 결제 로직이 섞임
- 이런 문제가 발생하는 이유는 바운디드 컨텍스트간의 강결합 때문
    - → 없애는 방법은 “이벤트”를 사용하는 것

## 10.2 이벤트 개요

---

### 10.2.1 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하려면 네 개의 구성요소를 구현해야 함
    
    ![20240320224423.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320224423.png)
    
- 이벤트 생성 주체: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- 이벤트 핸들러: 이벤트 생성 주체가 발생한 이벤트에 반응함
- 이벤트 디스패처: 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것

### 10.2.2 이벤트의 구성

- 이벤트의 구성 요소
    - 이벤트 종류: 클래스 이름으로 이벤트 종류 표현
    - 이벤트 발생 시간
    - 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련한 정보

```java
// 배송지 변경 이벤트 
public class ShippingInfoChangedEvent { // 이벤트는 과거 시제를 사용함 
	private String orderNumber;
	private long timestamp;
	private ShippingInfo newShippingInfo;
}
```

### 10.2.3 이벤트 용도

- 이벤트는 두 가지 용도로 쓰임
    1. 트리거 → 주문 취소 이벤트를 트리거로 사용할 수 있음 (환불)
    2. 서로 다른 시스템 간의 데이터 동기화 → 배송지 변경 이벤트 (배송지 정보 동기화)

### 10.2.4 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 걸 방지할 수 있음

## 10.3. 이벤트, 핸들러, 디스패처 구현

---

### 10.3.1 이벤트 클래스

- 이벤트 자체를 위한 상위 타입은 존재하지 않음, 원하는 클래스를 이벤트로 사용하면 됨
- 이벤트 클래스의 이름은 과거 시제를 사용해야 한다는 점만 유의!
- 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함해야 함

### 10.3.2 Event 클래스와 ApplicationEventPublisher

- 이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher를 사용

### 10.3.3 이벤트 발생과 이벤트 핸들러

- 이벤트를 발생시킬 코드는 Events.raise() 메서드를 이용함
- 이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener를 사용해서 구현

### 10.3.4 흐름 정리

![20240320225431.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320225431.png)

1. 도메인 기능을 실행
2. 도메인 기능은 Event.raise()를 이용해서 발생시킴
3. Events.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트 출판
4. ApplicationEventPublisher는 @EventListener 가 붙은 메서드를 찾아 실행

## 10.4 동기 이벤트 처리 문제

---

- 이벤트를 사용해서 강결합 문제는 해소했지만, 외부 서비스에 영향을 받는 문제는 아직 남아있음
- 방법 두가지
    1. 이벤트를 비동기로 처리
    2. 이벤트와 트랜잭션을 연계 

## 10.5 비동기 이벤트 처리

---

- 이벤트를 비동기로 구현하는 방법
    1. 로컬 핸들러를 비동기로 실행
    2. 메시지 큐 사용
    3. 이벤트 저장소와 이벤트 포워더 사용
    4. 이벤트 저장소와 이벤트 제공 API 사용

### 10.5.1 로컬 핸들러 비동기 실행

- 스프링이 제공하는 @Async 를 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행
    - @EnableAsync 를 사용해 비동기 기능 활성화

### 10.5.2 메시징 시스템을 이용한 비동기 구현

- 카프카나 래빗MQ와 같은 메시징 시스템 사용
    
    ![20240320230615.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320230615.png)
    

### 10.5.3 이벤트 저장소를 이용한 비동기 처리

1. 이벤트를 일단 DB에 저장한 뒤 별도 프로그램을 이용해 이벤트 핸들러에 전달
    
    ![20240320230719.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320230719.png)
    
2. 이벤트를 외부에 제공하는 API를 사용
    
    ![20240320230807.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320230807.png)
    
- 두가지 방식 모두 이벤트를 저장할 저장소가 필요함
    
    ![20240320230853.png](Ch10%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20262b147184124e17b8e04e18b2df5c8e/20240320230853.png)
    
- 코드 구현 내용… 생략

## 10.6 이벤트 적용 시 추가 고려 사항

---

- 이벤트를 구현할 때 추가로 고려할 점
    1. 이벤트 소스를 EventEntry에 추가할지 여부 
        1. 기본 EventEntry는 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없음 
    2. 포워더에서 전송 실패를 얼마나 허용할 것인지 
        1. 포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어 전송 시도
        2. 특정 이벤트에서 계속 실패한다면? 나머지 이벤트도 전송 못함
        3. 즉 포워더를 구현할 때는 실패한 이벤트의 재전송 횟수 제한을 두어야 함 
    3. 이벤트 손실
        1. 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실함
    4. 이벤트 순서
        1. 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수 있음
    5. 이벤트 재처리 
        1. 동일 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정
        2. 혹은 이벤트를 멱등으로 처리

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려

- 이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 함
    - 트랜잭션이 성공할 때만 이벤트 핸들러 실행 → @TransactionalEventListener: 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 함
    - TransactionPhase.AFTER_COMMIT을 사용하면 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행함