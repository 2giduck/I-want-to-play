# Ch3. 애그리거트

최종 편집 일시: 2024년 1월 23일 오후 9:28
즐겨찾기: No
프로젝트: (book) 도메인 주도개발 시작하기  (https://www.notion.so/book-cb10f7efd53346d0b5cd32514b34471b?pvs=21)
상태: inbox
영역: 독서 (https://www.notion.so/ae1f1383afe948e190d4240a466949ab?pvs=21), 개발 (https://www.notion.so/c09a0ad3a54348ff820deae0b1652e4b?pvs=21)

## 3.1 애그리거트

- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다.
- 복잡한 도메인을 이해하고 관리하기  쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요 → 애그리거트
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 됨
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음
- 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않음
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높음
- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드뭄

## 3.2 애그리거트 루트

- 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티

### 3.2.1 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨
    - 단순히 필드를 변경하는 set 메서드를 공개 범위로 만들지 않음
    - 밸류 타입은 불변으로 구현
- 밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능함

### 3.2.2 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성함

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋음
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함
- 애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안 됨

## 3.3 리포지터리와 애그리거트

- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
- 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 함

## 3.4 ID를 이용한 애그리거트 참조

- 애그리거트에 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같음
- 애그리거트를 직접 참조하면 성능과 관련된 여러가지 고민을 해야 함
- 방법 → ID를 이용해서 참조하기
- ID를 이용해 참조하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결됨

### 3.4.1 ID를 이용한 참조와 조회 성능

- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있음
- 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 마이바티스와 같은 기술을 사용해서 구현할 수도 있음

## 3.5 애그리거트 간 집합 연관

- 애그리거트 간 1-N 관계는 Set과 같은 컬렉션을 이용해서 표현할 수 있음

## 3.6 애그리거트를 팩토리로 사용하기

- 애그리거트가 갖고있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.