# Ch4. 리포지터리와 모델 구현

## 4.1 JPA를 이용한 리포지터리 구현

- 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM 만한 것이 없음

### 4.1.1 모듈 위치

- 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야함

### 4.1.2 리포지터리 기본 기능 구현

## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현

## 4.3 매핑 구현

### 4.3.1 엔티티와 밸류 기본 매핑 구현

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다
- 밸류는 @Embeddable로 매핑 설정한다
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다

### 4.3.2 기본 생성자

- 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.
- 다른 코드에서 기본 생성자를 사용하지 못하도록 protected를 사용한다

### 4.3.3 필드 접근 방식 사용

### 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리

- AttributeConverter는 밸류 타입과 칼럼 데이터 간의 변환을 처리하기 위한 기능을 정의한다

### 4.3.5 밸류 컬렉션: 별도 테이블 매핑

### 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑

- AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다.
- 단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.

### 4.3.7 밸류를 이용한 ID 매핑

- 밸류 타입을 식별자로 매핑하면 @Id 대신 @EmbeddedId 애너테이션을 사용한다
- JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다
- 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.

### 4.3.8 별도 테이블에 저장하는 밸류 매핑

- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.
- 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다.
- 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다.
- 밸류를 매핑 한 테이블을 지정하기 위해 @SecondaryTable과 @AttributeOverride을 사용한다
- @SecondaryTable을 사용하면 두 테이블을 조인해서 데이터를 조회한다.

### 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

- 개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있다.

### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

- 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용할 수 있다.

## 4.4 애그리거트 로딩 전략

- 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다
    - 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 함
    - 표현 영역에서 애그리거트 상태 정보를 보여줄 때 필요함

## 4.5 애그리거트의 영속성 전파

- 애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미함
- @Embeddable 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다
- 반면 애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설계되어야 한다.

## 4.6 식별자 생성 기능

- 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 한다.

## 4.7 도메인 구현과 DIP

- DIP를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준 영향을 받지 않도록 하기 위함이다.
- 변경이 거의 없는 상태에서 미리 대비하는 것은 과하다고 생각함
- DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성을 가져가면서 구조적인 유연함은 어느 정도 유지