### 04. 데이터 다루기

#### 4.1 단건 문서 API
###### 4.1.1 색인 API 
- 문서 단건을 색인
- POST 메서드는 _id 값을 지정하지 않고 색인을 요청할 경우에 사용
- _create는 항상 새 문서를 생성하는 경우에만 허용하고 문서를 덮어씌우면서 색인하는 것을 금지함
- 색인 시 refresh 매개변수를 지정하면 문서를 색인한 직후에 해당 샤드를 refresh 해서 즉시 검색 가능하게 만들 것인지 여부 지정 가능
  - true: 색인 직후 refresh
  - wait_For: 기다린 후 응답 반환
- true/wait_For 지정하기 전에 반드시 성능에 대한 고려가 필요함 
- 기본적으로는 문서 색인 요청의 결과가 검색 역색인에 즉시 반영되어야 하는 요청은 많지 않도록 설계하는 것이 바람직함 
###### 4.1.2 조회 API
- 색인이 refresh 되지 않은 상태에서도 변경된 내용을 확인 가능함
- translog에서도 데이터를 읽어올 수 있음 
- 기본적인 조회에는 _doc 사용
- 메타데이터가 필요하지 않으면 _source 사용 
- 조회 API 사용시 _source_includes와 _source_excludes를 사용하면 결과에 원하는 필드만 필터링해 사용할 수 있음
###### 4.1.3 업데이트 API
- 지정한 문서 하나를 업데이트
- 기본적으로 부분 업데이트로 동작함
- 기존 문서의 내용을 조회한 뒤 부분 업데이트될 내용을 합쳐 새 문서를 만들어 색인함
- 이 과정에서 _source를 조회하기 때문에 _source를 비활성화 시킨 경우 사용할 수 없음
- 업데이트 API를 호출하면 그 작업을 수행하기 전에 내용이 기존 문서 내용을 실질적으로 변경하는지 여부를 확인함
- noop요청이라면 쓰기 작업을 수행하지 않음
- noop을 검사하는 것은 불필요한 디스크 I/O를 줄일 수 있음 
- detect_noop은 일반적인 상황에서 활성화하는 것이 좋음 
- 기존 문서가 없을 때 새로 문서를 추가하는 upsert기능이 필요하다면 다음과 같이 doc_as_upsert 옵션을 true로 지정해 줌 
- 엘라스틱서치는 자체 언어인 painless를 사용함 
###### 4.1.2 삭제 API
- 일반적으로 한 번 삭제한 문서는 되돌릴 수 없기 때문에 삭제 작업은 항상 신중해야 함

#### 4.2 복수 문서 API
- 최대한 단건 문서 API보다는 복수 문서 API를 사용해야 함 
###### 4.2.1 bulk API 
- 여러 색인, 업데이트, 삭제 작업을 한 번의 요청에 담아서 보내는 API
- 요청 본문을 JSON이 아니라 NDJSON 형태로 만들어서 보냄
- Content-Type 헤더도 application/json 대신 application/x-ndjson 사용 
- 항상 작업 순서가 보장되는 것은 아님
- 동일한 문서에 대한 요청은 bulk API에 기술된 순서대로 동작함
###### 4.2.2 multi get APi
- _id를 여럿 지정하여 해당 문서를 한 번에 조회하는 API
###### 4.2.3 update by query
- 검색 쿼리를 통해 주어진 조건을 만족하는 문서를 찾은 뒤 그 문서를 대상으로 업데이트나 삭제 작업을 실시하는 API
- script를 통한 업데이트만을 지원함 
- query절의 검색 조건에 맞는 문서를 찾아 스냅샷을 찍은 후 각 문서마다 지정된 스크립트에 맞게 업데이트를 실시함 
- 도중 다른 작업으로 인해 문서에 변경이 생기면 이를 업데이트 하지 않음 
  - conflicts 매개변수를 통해 동작 방식을 지정할 수 있음
- 작업이 중단되어도 그때까지 업데이트 된 내용이 롤백되지는 않음 
- 적절한 스로틀링 적용을 통해 작업의 속도를 조정하고 클러스터 부하와 서비스 영향을 최소화할 수 있음 
- tasks API를 사용해서 update by query를 비동기적으로 요청할 수 있음
- wait_for_completion 매개변수를 false로 지정하면 비동기적 처리를 할 수 있음 
- _rethrottle을 사용하면 작업의 스로틀링을 동적으로 변경할 수 있어 문제 상황에 유연하게 대처 가능 
- 작업의 상황을 충분히 확인 했다면 다음과 같이 .tasks 인덱스에서 문서를 삭제하면 좋음 
- slices 매개변수를 지정하면 검색과 업데이트를 지정한 개수로 쪼개 병렬적으로 수행함 
- 기본적으로 샤드를 기준으로 작업을 쪼개는 것이기 때문에 요청 슬라이스가 동일한 작업량을 배분받는 것은 아니라는 사실을 알고 있어야 함 
###### 4.2.4 delete by query 

#### 4.3 검색 API
###### 4.3.1 검색 대상 지정
- GET과 POST중 무엇을 사용해도 동작은 동일함
###### 4.3.2 쿼리 DSL과 쿼리 문자열 검색
- 요청 본문과 q 매개변수가 동시 지정된 경우 q 매개변수가 우선 작동
- 루씬 쿼리 문자열 지정 검색은 간단한 요청을 이용하는 경우에 사용됨
###### 4.3.3 match_all 쿼리
- 모든 문서를 매치하는 쿼리
###### 4.3.4 match 쿼리
- 지정한 필드의 내용이 질의어라 매치되는 문서를 찾는 쿼리
###### 4.3.5 term 쿼리
- 지정한 필드의 값이 질의어와 정확히 일치하는 문서를 찾는 쿼리 
###### 4.3.6 terms 쿼리
- 질의어를 여러개 지정할 수 있음 
###### 4.3.7 range 쿼리
- 지정한 필드의 값이 특정 범위 내에 있는 문서를 찾는 쿼리
- range 쿼리는 부담이 없는 상황에서만 사용해야 함 
###### 4.3.8 prefix 쿼리
- 필드의 값이 지정한 질의어로 시작하는 문서를 찾는 쿼리
- 단발성 쿼리 정도는 감수함 
###### 4.3.9 exists 쿼리
- 지정한 필드를 포함한 문서를 검색
###### 4.3.10 bool 쿼리
- 여러 쿼리를 조합하여 검색하는 쿼리 
- 필터 문맥: 점수를 매기지 않고 조건을 만족하는지 여부만 파악
- 쿼리 문맥: 유사도 점수를 매기는 과정 
- 어떤 쿼리가 먼저 수행되는지 규칙은 없음 
###### 4.3.11 constant_score 쿼리
- 하위 filter 부분에 지정한 쿼리를 필터 문맥에서 검색하는 쿼리 
###### 4.3.12 그외 주요 매개변수 
- explain: 검색을 수행하는 동안 점수가 어떻게 계산되는지 설명함
- search_type: 유사도 점수를 계산할 때 각 샤드 레벨에서 계산을 끝낼지 여부 선택
###### 4.3.13 검색 결과 정렬
- 요청 본문에 sort를 지정하면 검색 결과를 정렬함
- 정렬에 사용할 수 있는 타입과 불가능한 타입이 있음
- _score는 검색을 통해 계산된 유사도 점수로 정렬함 
###### 4.3.14 페이지네이션
- from과 size, 검색에 매칭되는 전체 문서를 모두 확인할 때 사용하는 scroll

#### 4.4 집계
###### 4.4.1 집계 기본
- 집계의 대상을 추려낼 검색 조건을 검색 API에 담은 뒤 집계 조건을 추가해서 호출함 
- size를 0으로 요청하는 것이 이득
###### 4.4.2 메트릭 집계
- 문서에 대한 산술적인 연산을 수행함
- stats: 필드의 평균, 최댓값, 최솟값, 핪, 개수를 모두 계산하여 반환
- 다중 값 숫자 메트릭 집계: 여러 숫자 값을 한꺼번에 반환하는 집계
- cardinality: 지정한 필드가 가진 고유한 값의 개수를 계산해 반환
###### 4.4.3 버킷 집계
- 문서를 특정 기준으로 쪼개어 여러 부분 집합으로 나눔 
- 문서를 여러 구간의 버킷으로 나눈 뒤 각 버킷에 대해서 하위 집계를 수행함
- histogram: 버킷의 간격을 지정함 
- terms: 지정한 필드에 대해 가장 빈도수가 높은 term 순서대로 버킷 생성
- composite: sources로 지정된 하위 집계의 버킷 전부를 페이지네이션을 이용해 효율적으로 순회하는 집계 
###### 4.4.4 파이프라인 집계
- 문서나 필드의 내용이 아니라 다른 집계 결과를 집계 대상으로 함 
- cumulative_sum: 다른 집계의 값을 누적하여 합산 
- max_bucket: 다른 집계의 결과를 받아서 그 결과가 가장 큰 버킷의 key와 결괏값을 구함

#### 4.5 서비스 코드에서 엘라스틱서치 클라이언트 이용 
###### 4.5.1 저수준 REST 클라이언트
- HTTP 통신
- 응답을 역직렬화 하는 등의 작업은 사용자가 해야 함 
###### 4.5.2 고수준 REST 클라이언트
- 엘라스틱서치 API를 클라이언트 라이브러리의 API로 노출함
- 버전 호환성 이슈가 있음 
###### 4.5.3 자바 클라이언트
- 개발하기 편리함
- 엘라스틱 서치 서버의 내부 구현 사항과의 결합도를 낮추고 클라이언트와 서버의 호환 이슈를 줄임
- 구현해야 할 비즈니스 로직과 타입에 집중함 