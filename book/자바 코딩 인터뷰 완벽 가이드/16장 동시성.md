# 16장. 동시성

## 16.1 자바 동시성(멀티스레딩)의 개요

---

- 프로세스: 프로그램 또는 애플리케이션의 실행 인스턴스
- 스레드: 프로세스의 실행 가능한 가장 작은 작업 단위
- 동시성: 하나의 애플리케이션에서 여러 작업
- 병렬성: 애플리케이션이 서로 다른 개별 작업을 동시에 처리하는 능력

## 16.2 기술 인터뷰

---

### 16.2.1 기술 인터뷰 1: 스레드 생명 주기 상태

- 몇 개의 문장으로 자바 스레드의 상태를 열거하고 설명하세요
    - 자바 스레드의 상태는 Thread.State 열거형으로 나타낼 수 있음
    - 생성 상태: 생성되었지만 시작되지 않음
    - 실행 대기 상태: 실행 중이거나 실행할 준비가 됨
    - 블록 상태: 필요한 록을 얻기 전까지 블록 상태에 있음
    - 일시 정지 상태: 다른 스레드가 작업 완료하기를 기다릴 때
        - 종료 상태: 비정상적으로 중단되거나 성공적으로 작업을 완료한 자바 스레드 상태 ]

### 16.2.2 기술 인터뷰 2: 교착 상태

- 교착 상태란 무엇인가요?
    - 순환 대기 또는 죽음의 포옹
    - 교착 상태는 애플리케이션을 부분적으로 또는 완전히 블록시킬 수 있음

### 16.2.3 기술 인터뷰 3: 경쟁 상태

- 경쟁 상태
    - 임계 구역: 여러 스레드에서 실행할 수 있고, 공유 데이터와 같은 공유 리소스를 사용하는 코드 부분
    - 경쟁 상태는 스레드가 임계 구역을 스레드 동기화 없이 통과할 때 발생함
    - 방지하는 방법: 록, 동기화 블록, atomic 변수와 volatile 변수, 메시지 패싱 등

### 16.2.4 기술 인터뷰 4: 재진입 가능한 록

- 재진입 가능한 록: 보통 프로세스가 교착 상태에 빠지지 않고 여러 번 록을 획득할 수 있음을 의미
- 재진입 불가능한 록: 프로세스가 이미 획득한 록을 한번 더 획득하려고 하면 블록됨

### 16.2.5 기술 인터뷰 5: Executor와 ExecutorService

- Executor: 작업 실행 전용 인터페이스
- ExecutorService: 다양한 추가 메서드를 제공하는 더 복잡하면서 포괄적인 인터페이스

### 16.2.6 기술 인터뷰 6: Runnable과 Callable

- Runnable
    - run이라는 단일 메서드를 제공하는 함수형 인터페이스
    - run 메서드는 매개변수가 없으며 void를 반환함
    - 스레드의 실행 결과를 신경쓰지 않는 시나리오에 적합함
- Callable
    - call이라는 단일 메서드를 제공하는 함수형 인터페이스
    - 제네릭 값을 반환하며 확인된 예외를 던질 수 있음
    - 빕동기 작업을 시작한 다음 반환된 Future 인스턴스를 호출하여 값을 얻어내는 시나리오에서 유용함

### 16.2.7 기술 인터뷰 7: 기아 상태

- 기아 상태: CPU 시간이나 공유 리소스에 전혀 접근하지 않는 스레드
- 방지 → 공정한 록을 사용함
- 기아 상태를 방지하면서 동시에 여러 스레드를 실행하려면 자바의 Semaphore 클래스를 사용하면 됨

### 16.2.8 기술 인터뷰 8: 라이브 록

- 라이브 록
    - 두 스레드가 서로 다른 스레드에 응답하는 작업을 계속 수행할 때
    - 스레드가 자신이 해야 할 작업을 전혀 실행하지 못함

### 16.2.9 기술 인터뷰 9: start와 run 메서드

- start는 새 스레드를 생성
- run은 생성하지 않음
- 스레드 객체에서 start 메서드를 두번 호출하면 IllegalStateException이 발생하지만 run 메서드는 두번 호출해도 예외가 발생하지 않음

### 16.2.10 기술 인터뷰 10: Thread와 Runnable

- 주로 Runnable을 구현하는 방법을 선호함
- Runnable을 구현하면 추가로 다른 클래스를 확장할 수도 있음
- Runnable을 구현하면 작업의 정의를 작업의 실행과 분리할 수 있음

### 16.2.11 기술 인터뷰 11: CountDownLatch와 CyclicBarrier

### 16.2.12 기술 인터뷰 12: wait와 sleep

- 동기화 환경이 필요한가를 확인하는 것
- wait메서드는 동기화 환경에서 호출되어야 함
- sleep메서드는 동기화 환경이 필요하지 않으
- wait 메서드는 Object 클래스에서 작동하고 sleep 메서드는 현재 스레드에서 작동함

### 16.2.13 기술 인터뷰 13: ConcurrentHashMap과 HashTable

- ConcurrentHashMap이 Hashtable보다 처리 속도가 빠른 이유는?
    - ConcurrentHashM은 내부적으로 맵을 세그먼트로 나누고 업데이트 작업 중에 특정 세그먼트만 잠금
    - HashTable은 업데이트 중에 전체 맵을 잠금

### 16.2.14 기술 인터뷰 14: ThreadLocal

- ThreadLocal
    - 자바는 각 스레드의 값을 별도로 저장하고 검색하는 ThreadLocal 클래스를 제공함
    - 하나의 ThreadLocal 인스턴스는 여러 스레드의 값을 저장하고 검색할 수 있음

### 16.2.15 기술 인터뷰 15: submit과 execute

### 16.2.16 기술 인터뷰 16: interrupted와 isInterrupted

### 16.2.17 기술 인터뷰 17: 스레드 중단

- 자바는 스레드를 차단하는 선제적인 방법을 제공하지 않음
- 작업을 취소하려면 일반적으로 플래그 조건 기반의 반복문을 사용해야 함
- 이 플래그는 일반적으로 volatile 변수로 선언함

### 16.2.18 기술 인터뷰 18: 스레드 사이의 데이터 공유

- 2개의 스레드는 스레드 안전을 보장하는 공유 객체나 자료구조를 기반으로 데이터를 공유할 수 있음
- 자바는 BlockingQueue 인터페이스, LinkedBlokingQueue 같은 스레드 안정성을 보장하는 내장 자료구조 집합을 제공

### 16.2.19 기술 인터뷰 19: ReadWriteLock

### 16.2.20 기술 인터뷰 20: 생산자-소비자