# 6장. 객체지향 프로그래밍

## 6.1 객체지향 프로그래밍의 개념 이해

---

### 6.1.1 객체란 무엇인가?

- 객체는 객체지향 프로그래밍의 핵심 개념 중 하나
- 객체는 실세계의 개체
- 객체는 상태(필드)와 동작(메서드)을 가진다
- 객체는 클래스의 인스턴스를 나타낸다
- 객체는 메모리에서 공간을 차지한다
- 객체는 다른 객체와 소통할 수 있다
- 각기 다른 접근 제어자를 가짐
- 가변 또는 불변 속성을 가짐
- 가비지 컬렉터를 통해 수집됨

### 6.1.2 클래스란 무엇인가?

- 클래스는 객체지향 프로그래밍의 핵심 개념 중 하나
- 클래스는 객체를 생성하기 위한 템플릿
- 클래스는 인스턴스화하기 전까지는 메모리의 힙 영역을 소모하지 않음
- 클래스는 여러 번 인스턴스화 할 수 있음
- 하나의 클래스는 하나의 작업만 함

### 6.1.3 추상화란 무엇인가?

- 추상화는 사용자와 관련 있는 내용만 노출하고 나머지 세부 내용은 숨기는 개념
- 추상화를 통해 사용자는 애플리케이션이 일을 수행하는 방법이 아닌 애플리케이션이 수행하는 일 자체에 집중할 수 있음

### 6.1.4 캡슐화란 무엇인가?

- 캡슐화는 객체 상태가 외부로부터 숨겨진 상황에서 이 상태에 접근하는 일련의 public 메서드만 노출하는 기법
- 각 객체가 클래스 내에서 객체의 상태를 비공개로 유지할 때 성립
- 정보 은닉 매커니즘
- 느슨한 결합, 재사용성, 보안 및 테스트하기 쉬운 코드와 같은 여러가지 중요한 이점을 제공함
- 자바에서 캡슐화는 접근 제어자로 구현할 수 있음

### 6.1.5 상속이란 무엇인가?

- 다른 객체를 기반으로 하는 새로운 객체를 만들 수 있음
- 객체가 다른 객체의 코드를 재사용할 수 있도록 허용하여 코드의 재사용성을 유지함
- 상속은 IS-A 관계라고 하며 부모-자녀 관계라고도 함
- 자바에서 상속은 extends 키워드로 구현할 수 있음
- 상속된 객체는 슈퍼클래스라고 하고, 슈퍼클래스를 상속받은 객체는 서브클래스라고 함
- 자바에서는 여러 클래스를 상속할 수 없음

### 6.1.6 다형성이란 무엇인가?

- 다형성은 때에 따라 객체가 다르게 동작할 수 있도록 함
- 다형성은 메서드 오버로딩이나, 메서드 오버라이딩을 통해 형성될 수 있음

### 6.1.7 연관이란 무엇인가?

- 서로 독립적인 두 클래스 간의 관계
- 소유자가 없음
- 일대일, 일대다, 다대일, 다대다 관계가 될 수 있음

### 6.1.8 집약이란 무엇인가?

- 단방향 연관 관계의 특별한 경우
- HAS-A 관계
- 집약 관계에 있는 두 객체는 자체 수명 주기를 가지며 객체 중 하나는 HAS-A 관계의 소유자

### 6.1.9 구성이란 무엇인가?

- 좀 더 제한적인 집약 관계
- 단독으로 존재할 수 없는 객체를 포함하는 HAS-A 관계를 나타냄
- 코드 재사용성과 객체의 가시성 제어를 유지

## 6.2 SOLID 원칙 이해

---

### 6.2.1 S란 무엇인가?

- S는 단일 책임 원칙
- S는 하나의 객체가 하나의 책임만 져야 한다는 의미
- S는 클래스를 단 한 가지 목표만 가지고 작성해야 한다는 것을 의미
- S는 애플리케이션 모듈 전반에서 높은 유지보수성과 가시성 제어 기능을 유지하는 원칙

### 6.2.2 O란 무엇인가?

- 개방-폐쇄 원칙
- 소프트웨어 컴포넌트는 확장에 관해 열려 있어야 하고 수정에 관해서는 닫혀 있어야 한다
- 다른 개발자가 작업을 수행하기 위해 반드시 수정해야 하는 제약 사항을 클래스에 포함해서는 안 된다
- O는 다양하고 직관적이며 유해하지 않는 방식으로 소프트웨어 확장성을 유지하는 원칙

### 6.2.3 L이란 무엇인가?

- 리스코프 치환 원칙
- 파생 타입은 반드시 기본 타입을 완벽하게 대체할 수 있어야 함
- 서브클래스의 객체는 슈퍼클래스의 객체와 반드시 같은 방식으로 동작해야 함
- 타입 변환 후에 따라오는 런타임 타입 식별에 유용한 원칙

### 6.2.4 I란 무엇인가?

- 인터페이스 분리 원칙
- 클라이언트가 사용하지 않을 불필요한 메서드를 강제로 구현해서는 안 된다
- 클라이언트가 사용하지 않을 메서드를 강제로 구현하는 일이 없을 때까지 하나의 인터페이스를 2개 이상의 인터페이스로 분할하는 원칙

### 6.2.5 D란 무엇인가?

- 의존관계 역전 원칙
- 구체화가 아닌 추상화에 의존해야 한다
- 다른 구상 모듈에 의존하는 구상 모듈 대신, 구상 모듈을 결합하기 위한 추상 계층을 사용해야 함

## 6.3 객체지향 프로그래밍, SOLID, GOF 디자인 패턴과 관련한 유명 질문

---

### 6.3.1 객체지향 프로그래밍에서 메서드 오버라이딩이란 무엇인가?

- 같은 이름과 시그니처를 가지면서 다르게 동작하게 2개의 메서드를 작성하는 것
- 상속 혹은 런타임 다형성에 사용될 수 있음
- static, private, final이 아님
- 자바는 객체 타입에 따라 호출할 실제 메서드를 런타임에 결정함
- 최소한의 코드 변경으로 새로운 기능을 추가할 수 있음

### 6.3.2 객체지향 프로그래밍에서 메서드 오버로딩이란 무엇인가?

- 같은 이름이지만 다른 시그니처와 다른 기능을 하도록 2개의 메서드를 작성하는 것
- 모두 static이거나 static이 아니어야 함
- 동일 시그니처지만 반환 타입이 다른 경우에는 유효한 메서드 오버로딩이 아님

### 6.3.3 자바에서 공변 메서드 오버라이딩이란 무엇인가?

- 공변 오버라이딩 메서드는 실제 반환 타입의 하위 타입을 반환할 수 있음

### 6.3.4 오버라이딩 및 오버로딩 메서드에서 예외를 다룰 때 주요 제한 사항은 무엇인가?

- 오버라이딩
    - 확인되지 않은 예외를 발생시킬 수 있음
    - 확인된 예외의 경우 오버라이드된 메서드의 확인된 예외 혹은 그 서브클래스 예외만 발생시킬 수 있음
- 오버로딩
    - 어떠한 제한 사항도 없음

### 6.3.5 슈퍼클래스의 오버라이드된 메서드를 서브클래스의 오버라이딩 메서드에서 어떻게 호출할 수 있는가?

- super 키워드를 이용해 호출할 수 있음

### 6.3.6 main 메서드를 오버라이드 또는 오버로딩 할 수 있는가?

- main 메서드는 static 메서드
- 오버라이딩은 불가능, 오버로딩은 가능

### 6.3.7 자바에서 static이 아닌 메서드를 static 메서드로 오버라이드 할 수 있는가?

- static이 아닌 메서드는 static 메서드로 오버라이드 할 수 없음

### 6.3.8 자바 인터페이스 안에 abstract가 아닌 메서드를 포함할 수 있는가?

- 자바 8 전까지는 인터페이스 안에 abstract가 아닌 메서드를 사용할 수 없었음
- 자바 8부터는 구현된 메서드를 인터페이스에 추가할 수 있음
    - default, static 키워드

### 6.3.9 default 메서드를 가지는 인터페이스와 추상 클래스의 주요 차이점은 무엇인가?

- 인터페이스는 생성자를 지원하지 않는 방면 추상 클래스는 생성자를 가짐
    - 즉, 추상 클래스는 상태를 가질 수 있음
- default 메서드는 클라이언트 코드에 영향을 미치지 않고 상태를 변경하지 않으면서 인터페이스에 추가 기능을 더하는 방법을 나타냄

### 6.3.10 추상 클래스와 인터페이스의 주요 차이점은 무엇인가?

- 자바 8 이전까지는 추상 클래스는 abstract가 아닌 메서드를 포함할 수 있는 반면에 인터페이스는 그러한 메서드를 포함할 수 없었음
- 자바 8부터는 추상 클래스가 생성자와 상태를 가질 수 있는 반면에 인터페이스는 이들을 가질 수 없다는 차이점이 있음

### 6.3.11 abstract 메서드가 없는 추상 클래스를 만들 수 있는가?

- 만들 수 있음
- abstract 키워드를 클래스에 추가하면 추상 클래스가 됨

### 6.3.12 추상이면서 동시에 final인 클래스를 만들 수 있는가?

- final 클래스는 서브클래스화 되거나 상속할 수 없음
- 추상 클래스는 확장을 통해서만 사용할 수 있음
- 반대되는 개념이므로 컴파일러에서 오류가 발생함

### 6.3.13 다형성, 오버라이딩, 오버로딩의 차이는 무엇인가?

- 오버로딩 기법은 컴파일 타임 다형성
- 오버라이딩 기법은 런타임 다형성

### 6.3.14 바인딩 작업이란 무엇인가?

- 바인딩 작업은 코드에서 참조한 결과로 호출할 메서드 또는 변수를 결정함
- 메서드 호출을 메서드 본문에 연결하는 과정을 바인딩 작업이라고 함

### 6.3.15 정적 바인딩과 동적 바인딩의 주요 차이는 무엇인가?

- 정적 바인딩
    - 컴파일 시간에 발생
    - private, static, final 메서드 혹은 변수는 정적 바인딩 사용
- 동적 바인딩
    - 런타임 시간에 발생
- 정적 바인딩은 클래스 정보를 통해 결정되며 동적 바인딩은 Object에 의해 결정됨

### 6.3.16 자바에서 메서드 하이딩이란 무엇인가?

- 메서드 하이딩은 정적 메서드에 한정됨
- 슈퍼클래스와 서브클래스에서 같은 시그니처와 이름을 가진 2개의 static 메서드를 선언한다면 두 메서드는 서로를 숨김
- 슈퍼클래스에서 메서드를 호출하면 슈퍼클래스의 static 메서드가 호출, 서브클래스에서 호출하면 서브클래스의 static 메서드가 호출됨
- static 메서드는 다형이 될 수 없어 하이딩은 오버라이딩과 다름

### 6.3.17 자바에서 가상 메서드를 작성할 수 있는가?

- 자바에서 static이 아닌 메서드는 모두 기본적으로 가상 메서드
- private 또는 final 키워드로 표시하여 가상이 아닌 메서드를 작성할 수 있음
- 즉, 상속이 될 수 있는 메서드는 가상 메서드

### 6.3.18 추상화와 다형성의 차이는 무엇인가?

- 추상화가 인터페이스와 추상 클래스를 통해 구현되는 반면 다형성은 오버라이딩과 오버로딩으로 구현

### 6.3.19 다형성을 구현하는 방법으로 오버로딩을 구현할 수 있는가?

- 논쟁의 여지가 있음

### 6.3.20 데커레이터 패턴에 적합한 객체지향 프로그래밍 개념은 무엇인가?

- “구성”
- 이 개념을 통해 데커레이터 디자인 패턴은 기존 클래스를 수정하지 않고도 새로운 기능을 제공함

### 6.3.21 싱글턴 패턴은 언제 사용해야 하는가?

- 클래스의 인스턴스가 하나만 필요할 때 사용
- 다만 싱글턴은 클래스 간 결합을 증가시키고 개발, 테스트 및 디버깅 중에 병목 현상을 발생시킬 수 있으므로 주의해서 사용해야 함

### 6.3.22 전략 패턴과 상태 패턴의 차이는 무엇인가?

- 상태 패턴은 상태에 따라 특정 작업을 수행하도록 설계
    - 클래스를 변경하지 않는 환경에서 서로 다른 상태의 특정 동작을 나타냄
- 전략 디자인 패턴은 코드를 수정하지 않고 여러 알고리즘을 전환해 사용하기 위한 패턴

### 6.3.23 프록시 패턴과 데커레이터 패턴의 차이는 무엇인가?

- 프록시 디자인 패턴은 무언가에 대한 접근 제어 게이트웨이를 제공하는 데 유용함
    - 실제 객체를 대신할 대리 객체를 생성함
- 데커레이터 패턴은 객체를 생성하지 않으며 런타임에 기존 객체를 새로운 기능으로 장식

### 6.3.24 퍼사드 패턴과 데커레이터 패턴의 차이는 무엇인가?

- 퍼사드 패턴은 객체에 새로운 기능을 추가하지 않음

### 6.3.25 템플릿 메서드 패턴과 전략 패턴의 주요 차이는 무엇인가?

### 6.3.26 빌더 패턴과 팩토리 패턴의 주요 차이는 무엇인가?

### 6.3.27 어댑터 패턴과 브릿지 패턴의 주요 차이는 무엇인가?