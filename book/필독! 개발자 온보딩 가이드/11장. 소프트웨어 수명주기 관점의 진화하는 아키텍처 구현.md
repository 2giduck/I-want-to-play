### 11장. 소프트웨어 수명주기 관점의 진화하는 아키텍처 구현

#### 복잡도를 이해하자
- 의존성이 높으면 강한 결합과 변경의 영향도 확대로 인해 수정이 어렵다
- 모호성이 높으면 프로그래머는 변경의 부작용, 코드의 동작, 변경이 필요한 지점 등을 예측하기 어렵다
- 관성은 소프트웨어를 계속 사용하려는 성향을 말한다 

#### 진화하는 아키텍처를 위한 설계 원칙
- YAGNI 원칙: 당장 필요치 않다면 구현하지 말 것 
- 최소 충격 원칙: 사용자를 놀래키지 말 것 
- 도메인 지식은 캡슐화돼야 한다

#### 진화하는 API를 위한 설계 원칙
- API 크기는 작게 유지하자
- 잘 정의한 서비스 API를 노출하자
- API 변경에는 호환성을 유지하자
- API의 버전을 관리하자

#### 진화하는 데이터를 위한 설계 원칙
- 데이터베이스를 격리하자 
- 스키마를 사용하자 
- 스키마 마이그레이션을 자동화하자
- 스키마 호환성을 유지하자 

#### 개발자의 필수 체크리스트
- YAGNI 원칙을 기억하자
- 표준 라이브러리와 개발 패턴을 사용하자
- IDL을 이용해 API를 정의하자
- 외부 API에는 버전을 부여하고 문서화하자
- 애플리케이션 데이터베이스를 서로 격리하자
- 모든 데이터에는 명시적 스키마를 정의하자
- 마이그레이션 도구를 이용해 데이터베이스 스키마 관리를 자동화하자
- 다운스크림 컨슈머가 데이터를 사용하고 있다면 스키마 호환성을 유지하자 
