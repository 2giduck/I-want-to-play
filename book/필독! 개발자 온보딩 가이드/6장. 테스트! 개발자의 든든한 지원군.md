### 6장. 테스트! 개발자의 든든한 지원군

#### 테스트를 꼭 해야 할까
- 테스트의 목적
  - 코드의 동작 확인
  - 의도치 않게 코드의 동작이 바뀌는 것을 방지
  - 깔끔한 코드 작성을 도와줌

#### 테스트의 유형과 기법
- 단위 테스트: 코드의 단위, 즉 메소드나 동작 하나를 검증 
- 통합 테스트: 여러 컴포넌트가 함께 어우러져 동작하는지 검증
- 시스템 테스트: 시스템 전체를 검증함 
- 성능 테스트: 주어진 설정하에서 시스템의wwwwwwwwww 성능을 측정
  - 부하 테스트: 시스템에 다양한 수준의 부하를 걸고 성능 측정
  - 스트레스 테스트: 장애가 발생하는 수준까지 시스템 부하를 올림
- 인수 테스트: 사용자나 사용자의 대리인이 제공한 소프트웨어가 인수 조건을 만족하는지 검증 

#### 테스트 도구 
- 테스트 작성 도구: mocking
- 테스트 프레임워크: 셋업부터 마무리까지 테스트의 수명주기를 모델링해서 테스트를 실행하게 해주는 도구
- 코드 품질 도구: 코드 커버리지와 복잡도 등을 분석하거나 정적 분석을 통한 버그 발견 및 코딩 스타일 에러 검사 등에 사용함 

- 모킹 라이브러리
  - 객체지향 코드의 단위 테스트에 주로 사용됨
  - 모의 객체(mock): 실제 시스템이 제공하는 인터페이스를 유사하게 모방하는 스텁 객체 
- 테스트 프레임워크
  - 테스트 코드를 작성하고 실행하는 도구 
  - 테스트 조율을 통해 테스트를 격리하고 속도를 조정함 
- 코드 품질 도구
  - 고품질의 코드를 작성하는 데 도움이 되는 도구
  - 린터: 코드 품질 규칙을 강제하는 도구
  - 정적 코드 분석기: 일반적인 실수를 찾아줌 
  - 코드 스타일 검사기: 모든 소스코드를 동일한 방식으로 작성함 
  - 코드 커버리지 도구 

#### 개발자 스스로 직접 테스트를 작성하자
- QA의 역할
  - 블랙박스나 화이트박스 테스트 작성
  - 성능 테스트 작성
  - 통합 테스트, 사용자 인수 테스트, 시스템 테스트 수행
  - 테스트 도구 제공 및 유지보수
  - 테스트 환경과 인프라스트럭처 유지보수
  - 정식 테스트 인증과 릴리스 절차 정의 

- 테스트는 깔끔하게 작성하자 
  - 테스트에도 좋은 프로그래밍 기법을 적용해야 함 
- 과도한 테스트는 삼가자

#### 테스트 결정성: 항상 동일한 테스트 결과를 만들려면
- 결정적 코드: 입력이 같으면 그 출력도 항상 같은 코드 
- 비결정적 코드 제거 방법
  - 난수생성기에 적절한 시드값을 사용하자
  - 단위 테스트에서 원격 시스템을 호출해서는 안됨 
  - 클럭을 주입하자 
  - 슬립과 타임아웃의 사용을 삼가자 
  - 네트워크 소켓과 파일 핸들을 닫자 
  - 0번 포트에 바인딩하자
  - 파일과 데이터베이스에 대해 고유한 경로를 생성하자 
  - 이전 테스트의 상태를 격리하고 해제하자 
  - 테스트의 실행 순서에 의존하지 말자 

#### 개발자의 필수 체크리스트
- 버그가 재현되는지 테스트를 이용해 확인해보자
- 단위 테스트는 모의 객체 도구를 이용해 작성하자 
- 코드 품질 도구를 이용해 커버리지, 스타일, 복잡도를 검증하자
- 테스트가 사용하는 난수생성기에는 적절한 시드값을 적용하자
- 테스트에서 사용한 네트워크 소켓과 파일은 반드시 닫아주자
- 테스트에 고유한 파일 경로와 데이터베이스 ID를 생성하자
- 테스트 실행 사이에 남겨진 상태는 정리하자 

#### 레벨업을 위한 읽을거리 
- 단위 테스트
- 테스트 주도 개발
- 실용주의 프로그래머 
- 탐험적 테스팅