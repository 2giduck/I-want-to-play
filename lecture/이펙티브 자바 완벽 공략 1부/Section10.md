### Section 10. equals는 일반 규약을 지켜 재정의하라

#### 핵심 정리: equals를 재정의하지 않는 것이 최선
- 다음의 경우에 해당한다면 equals를 재정의할 필요가 없다.
  - 각 인스턴스가 본질적으로 고유하다
  - 인스턴스의 '논리적 동치성'을 검사할 필요가 없다
  - 상위 클래스에서 재정의한 equals가 하위 클래스에도 적절하다
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 

#### 핵심 정리: equals 규약
- 반사성: A.equals(A) == true
- 대칭성: A.equals(B) == B.equals(A)
- 추이성: A.equals(B) && B.equals(C), A.equals(C)
- 일관성: A.equals(B) == A.equals(B)
- null-아님: A.equals(null) == false

#### 핵심 정리: equals 구현 방법과 주의 사항
- ==연산자를 이용해 자기 자신의 참조인지 확인
- instanceof 연산자로 올바른 차입인지 확인
- 입력된 값을 올바른 타입으로 형변환
- 입력 객체와 자기 자신의 대응되는 핵심 필드가 일치하는지확인
- equals를 재정의할 때 hasCode도 반드시 재정의하자
- 너무 복잡하게 해결하지 말자
- Object가 아닌 타입의 매개변수를 받는 equals메서드는 선언하지 말자

#### 완벽 공략: Value 기반의 클래스
- 식별자가 없고 불변이다
- 식별자가 아니라 인스턴스가 가지고 있는 상태를 기반으로 구현한다
- == 오퍼레이션이 아니라 equals를 사용해서 동등성을 비교한다
- 동일한 객체는 상호교환 가능하다 

#### 완벽 공략: StackOverflowError
- 로컬 변수와 객체가 저장되는 공간: 스택과 힙
- 메소드 호출시 스택에 스택 프레임이 쌓임
- 더이상 스택 프레임을 쌓을 수 없다면 StackOverflowError

#### 완벽 공략: 리스코프 치환 원칙
- 하위 클래스의 객체가 상위 클래스 객체를 대신하더라도 소프트웨어의 기능을 깨트리지 않아야 한다